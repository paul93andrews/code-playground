<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Code-Wars Daily Challenges</title>
</head>
<body>
<script>
    // Your task is to convert strings to how they would be written by Jaden Smith.The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

    //         Example:

    //     Not Jaden - Cased: "How can mirrors be real if our eyes aren't real"
    //     Jaden - Cased: "How Can Mirrors Be Real If Our Eyes Aren't Real"

    const jadenCased = (str) => {
        const array = str.split(' ');
        let finalArray = [];
        for (word of array) {
            const uppercaseArray = [...word];
            let uppercaseLetter = uppercaseArray[0].toUpperCase();
            uppercaseArray.shift();
            uppercaseArray.unshift(uppercaseLetter);
            const jadenCasedWord = uppercaseArray.join('');  
            finalArray.push(jadenCasedWord);
        }
        const jadenCasedSentence = finalArray.join(' ');
        return console.log(jadenCasedSentence);
    }

    jadenCased("How can mirrors be real if our eyes aren't real");


    //Descending Order
    // Your task is to make a function that can take any non - negative integer as a argument and return it with its digits in descending order.Essentially, rearrange the digits to create the highest possible number.
    //         Examples:

    //     Input: 21445 Output: 54421

    //     Input: 145263 Output: 654321

    //     Input: 1254859723 Output: 9875543221

    const descendingOrder = number => {
        if (typeof number != 'number') {
            return console.log('put in a number ya fool!');
        }

        const numberStr = number.toString();
        const numberArray = [...numberStr];
        const sortedNumberArray = numberArray.sort();
        let reverseSortedArray = [];
        for (value of sortedNumberArray) {
            reverseSortedArray.unshift(value);
        }

        reverseNumberStr = reverseSortedArray.join('');
        const reverseNumber = Number(reverseNumberStr);
        return reverseNumber;
    }

    descendingOrder(21445);
    descendingOrder(123456789);
    descendingOrder(1021);


    //Isogram
    
    // An isogram is a word that has no repeating letters, consecutive or non - consecutive.Implement a function that determines whether a string that contains only letters is an isogram.Assume the empty string is an isogram.Ignore letter case.

    //     isIsogram("Dermatoglyphics") == true
    //     isIsogram("aba") == false
    //     isIsogram("moOse") == false // -- ignore letter case

    const isIsogram = str => {
        const lowerCaseStr = str.toLowerCase();
        const strArray = [...lowerCaseStr];
        let letterCount = {};

        for (letter of strArray) {
            if (letterCount[letter] === undefined) {
                letterCount[letter] = 1;
            }
            else {
                letterCount[letter]++
                return console.log(false);
            }
        }

        return console.log(true);
    }

    isIsogram('the');
    isIsogram('aba');
    isIsogram('moOse');

//   Funny string attachment  

// This time no story, no theory. The examples below show you how to write function accum:

// Examples:

// accum("abcd") -> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt") -> "C-Ww-Aaa-Tttt"

// The parameter of accum is a string which includes only letters from a..z and A..Z.

    const strAccum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        let newArray = [];

        for (let i = 0; i <= strArray.length - 1; i++) {
            if (i === 0) {
                const firstLetter = strArray[i];
                newArray.push(firstLetter + '-');
            }
            else if(i > 0 && i < strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i) + '-');
            }
            else if (i === strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i));
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(strAccum('abcd'));
    console.log(strAccum('cwAT'));

    const accum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        const newArray = strArray.map((letter, i) => {
            return letter + letter.toLowerCase().repeat(i);
        });
        const finalStr = newArray.join('-');
        return finalStr;
    }

    console.log(accum('abcd'));
    console.log(accum('cwAT'));

    // Given: an array containing hashes of names

    //     Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.

    //         Example:

    //     list([{ name: 'Bart' }, { name: 'Lisa' }, { name: 'Maggie' }])
    //     // returns 'Bart, Lisa & Maggie'

    //     list([{ name: 'Bart' }, { name: 'Lisa' }])
    //     // returns 'Bart & Lisa'

    //     list([{ name: 'Bart' }])
    //     // returns 'Bart'

    //     list([])
// returns ''

    const arrayList = [{name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'}];

    const list = array => {
            let newArray = [];
            for (obj of array) {
                newArray.push(obj.name);
            }
            const finalStr = newArray.map((name, i) => {
                if ((newArray.length - 1) === 0) {
                    return name;
                }
                else if (i === (newArray.length - 1)) {
                    return '& ' + name;
                }
                else if (i === (newArray.length - 2)) {
                    return name;
                }
                return name + ','
            }).join(' ');
            
            return finalStr;
    }

    console.log(list(arrayList)); 


    // Array Diff
    // Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

    //     It should remove all values from list a, which are present in list b.

    //         array_diff([1, 2], [1]) == [2]

    //     If a value is present in b, all of its occurrences must be removed from the other:

    //     array_diff([1, 2, 2, 2, 3], [2]) == [1, 3]

    const array_diff = (array1, array2) => {
        return array1.filter(item => {
            //very interesting quirk here with .filter() method, it doesn't return values of 0 in an array
            //this is because the value of 0 returns falsy, so filter doesn't recognize it and therefore doesn't return it in the new array
            return !array2.includes(item);
        })
    }

    console.log(array_diff([1, 2, 2, 2, 3, 0], [2]));



    // Write a function using recursion that takes a base and an exponent and outputs the power.

    //     e.g.

    //     power(2, 3) -> 8

    // power(4, 2) -> 16


    const power = (base, exponent) => {
        if (exponent <= 1) {
            return base
        }
        else {
            return base * power(base, exponent - 1);
        }
    }


    console.log(power(2, 3));
    console.log(power(4, 2));



    // Write a function that takes two arrays and returns their intersection as an array.

    //     intersection([1, 2, 3], [2, 3, 4]) -> [2, 3]

    // intersection([a, 1, 'foo'], ['foo', 17, a]) -> [a, 'foo']

    const intersection = (array1, array2) => {
        return array1.filter(item => {
            return array2.includes(item);
        })
    }

    console.log(intersection([1, 2, 3], [2, 3, 4]));
    console.log(intersection(['a', 1, 'foo'], ['foo', 17, 'a']));




    // Write a function that weaves 2 strings together.If one string is longer than the other, attach all letters left at the end.

    //     weave('abc', '123') -> 'a1b2c3'

    // weave('abcdefg', '123') -> 'a1b2c3defg'

    const weave = (str1, str2) => {
        const str1Array = [...str1];
        const str2Array = [...str2];
        let newArray = [];
        let length;

        if (str1Array.length - 1 > str2Array.length - 1) {
            length = str1Array.length - 1;
        }
        else {
            length = str2Array.length - 1;
        }

        for (let i = 0; i <= length; i++) {
            if (str1Array[i]){
                newArray.push(str1Array[i]);
            }
            if (str2Array[i]) {
                newArray.push(str2Array[i]);
            }
        }

        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(weave('abc', '123')); 
    console.log(weave('abcdefg', '123'));


    // Convert seconds to time format 
    
    // Write a function, which takes a non - negative integer(seconds) as input and returns the time in a human - readable format(HH: MM: SS)

    //     HH = hours, padded to 2 digits, range: 00 - 99
    //     MM = minutes, padded to 2 digits, range: 00 - 59
    //     SS = seconds, padded to 2 digits, range: 00 - 59

    //     The maximum time never exceeds 359999(99: 59: 59)

    //     You can find some examples in the test fixtures.

    const humanReadable = (secs) => {
        let seconds;

        let minutes = Math.floor(secs / 60).toString();
        let hours = Math.floor(secs / 3600).toString();
        seconds = (secs % 60).toString();
        
        if (hours >= 1) {
            minutes = (minutes % 60).toString();
        }
        if (hours >= 99) {
            hours = 99;
        }
        if (hours >= 0 && hours < 10) {
            hours = '0' + hours;
        }
        if (minutes >= 0 && minutes < 10) {
            minutes = '0' + minutes;
        }
        if (seconds >= 0 && seconds < 10) {
            seconds = '0' + seconds;
        }

        console.log(seconds);
        return `${hours}:${minutes}:${seconds}`;
    }

    console.log(humanReadable(1000));
    console.log(humanReadable(5));
    console.log(humanReadable(60));
    console.log(humanReadable(86399));
    console.log(humanReadable(359999));
    console.log(humanReadable(45296));

    const humanReadable2 = (time) => {
        //very interesting solution here
        //parseInt() will drop the decimal values on the number when converting to string
        const hours = parseInt(time / 3600);
        const minutes = parseInt(time / 60) % 60;
        const seconds = time % 60;
        //that gives us all of the values we needs

        const pad = (val) => {
            //this function creates the values we need for our final string
            //in a patterned fashion
            return val < 10 ? "0" + val : val;
        }

        return pad(hours) + ":" + pad(minutes) + ":" + pad(seconds);
    }

    //Write a function that counts the letters of multiple string values in an array
    //Then, return the letter count for each individual string as an object
    //Each object's letter count will be stored in an array to be returned by the function

    const countLetters = (array) => {
        let obj = {};
        let finalArray = [];

        for (word of array) {
            obj = {}
            let strArray = [...word];
            for (letter of strArray) {
                if (obj[letter] === undefined) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++
                }
            }
            finalArray.push(obj);
        }
        return finalArray;
    }

    console.log(countLetters(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    const countLetters2 = array => {
        return array.map(string => {
            const obj = {};
            [...string].map(letter => {
                if (!obj[letter]) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++;
                }
            })
            return obj
        })
    }

    console.log(countLetters2(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    //Find Int
    
    // Given an array, find the int that appears an odd number of times.

    //     There will always be only one integer that appears an odd number of times.

    const findOdd = (array) => {
        const obj = {}
        array.map(number => {
            if (!obj[number]) {
                obj[number] = 1;
            }
            else {
                obj[number]++;
            }
        })
        for (key in obj) {
            if (obj[key] % 2 !== 0) {
                return Number(key);
            }
        }
    }
    

    console.log(findOdd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    const findOdd2 = (xs) => xs.reduce((a, b) => a ^ b);

    console.log(findOdd2([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    console.log([ 1, 1, 2, 7, 2, 3, 3].reduce((a,b) => a ^ b));


    // A Narcissistic Number is a number which is the sum of its own digits, each raised to the power of the number of digits in a given base.In this Kata, we will restrict ourselves to decimal(base 10).

//     For example, take 153(3 digits):

//     1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 1 + 125 + 27 = 153

//     and 1634(4 digits):

//     1 ^ 4 + 6 ^ 4 + 3 ^ 4 + 4 ^ 4 = 1 + 1296 + 81 + 256 = 1634

//     The Challenge:

//     Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

//     Error checking for text strings or other invalid inputs is not required, only valid integers will be passed into the function.

    const narcissistic = num => {
        const numStr = `${num}`
        const numArray = [...numStr];
        const length = numArray.length;

        const finalSum = numArray
        .map(number =>  number ** length)
        .reduce((a,b) => a + b);

        if (finalSum === num) return true;
        else return false;
    }

    console.log(narcissistic(7));
    console.log(narcissistic(371));

    // Three conditions must be met for a valid experiment:

    //         Float parameter "h" in meters must be greater than 0
    //     Float parameter "bounce" must be greater than 0 and less than 1
    //     Float parameter "window" must be less than h.

    //     If all three conditions above are fulfilled, return a positive integer, otherwise return -1.
    //     Note:

    //     The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.

    const bouncingBalls = (h, b, w) => {
        const height = h > 0;
        const bounce = b < 1 && b > 0;
        const windowHeight = w < h;

        if (height && bounce && windowHeight) {
            let count = 1;
            let bounceHeight = b * h;

            for (i = bounceHeight; i > w; i *= b) {
                count = count + 2;
            }
            return count;
        }
        else return -1;
    }

    console.log(bouncingBalls(3, .66, 1.5));
    console.log(bouncingBalls(30, .66, 1.5));

    // Complete the method / function so that it converts dash / underscore delimited words into camel casing.The first word within the output should be capitalized only if the original word was capitalized(known as Upper Camel Case, also often referred to as Pascal case).
    //         Examples

    //     toCamelCase("the-stealth-warrior") // returns "theStealthWarrior"

    //     toCamelCase("The_Stealth_Warrior") // returns "TheStealthWarrior"

    // const toCamelCase = (str) => {
    //     if (str === '') return 
        
    //     const strArray = str.split(/[-_]+/g);
        
    //     const newArray = strArray.map(word => {
    //         if (word === strArray[0] && strArray[0] === strArray[0].toLowerCase()) {
    //             return word.replace(word[0], word[0].toLowerCase())
    //         }
    //         else {
    //             return word.replace(word[0], word[0].toUpperCase());
    //         }
    //     })  
    //     return newArray.join('');
    // }


    const toCamelCase = (str) => {
        const regExp = /[-_]\w/ig;
        return str.replace(regExp, (match) => {
            return match.charAt(1).toUpperCase();
        });
    }

    console.log(toCamelCase('the-stealth-warrior'));
    console.log(toCamelCase("The_Stealth_Warrior"));

    // Write a function that accepts an array of 10 integers(between 0 and 9), that returns a string of those numbers in the form of a phone number.
    //         Example:

    //     createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"

    //     The returned format must be correct in order to complete this challenge.
    //         Don't forget the space after the closing parenthesis!

    const createPhoneNumber = (array) => {
        return array.map((number, index) => {
            if (index === 0){
                return `(${number}`;
            }
            if (index === 2) {
                return `${number})`;
            }
            if (index === 3) {
                return ` ${number}`
            }
            if (index === 5) {
                return `${number}-`
            }
            return number;
        }).join('');
    }

    console.log(createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]));

    // The marketing team is spending way too much time typing in hashtags.
    //         Let's help them with our own Hashtag Generator!

    //     Here's the deal:

    //     It must start with a hashtag(#).
    //     All words must have their first letter capitalized.
    //     If the final result is longer than 140 chars it must return false.
    //     If the input or the result is an empty string it must return false.

    const generateHashtag = (str) => {
        if (str === '') return false;
        if (str.length >= 140) return false;
        const strArray = str.split(' ');
        strArray.unshift('#')
        let newArray = [];
        for (word of strArray) {
            if (word != '') {
                const lowerCase = word.charAt(0);
                const upperCase = word.charAt(0).toUpperCase();
                const newWord = word.replace(lowerCase, upperCase);
                newArray.push(newWord);
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(generateHashtag('hello        World'));
    console.log(generateHashtag(' Hello there thanks for trying my Kata'));

    // ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters after it in the alphabet.ROT13 is an example of the Caesar cipher.

    //     Create a function that takes a string and returns the string ciphered with Rot13.If there are numbers or special characters included in the string, they should be returned as they are.Only letters from the latin / english alphabet should be shifted, like in the original Rot13 "implementation".

    const rot13 = (str) => {
        const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        const strArray = [...str];
        const regex = /[\W\d0\s]/g;
        return strArray.map((letter, index) => {
            if (regex.test(letter)){
                console.log(regex.test(letter));
                return letter;
            }
            else if (letter === letter.toUpperCase()){
                return checkLetterPosition(alphabet, letter).toUpperCase();
            }
            else return checkLetterPosition(alphabet, letter);
        }).join('');
    }

    const checkLetterPosition = (arr, letter) => {
        return (arr.indexOf(letter.toLowerCase()) > 12)
        ?
        arr[12 - ((arr.length - 1) - arr.indexOf(letter.toLowerCase()))]
        :
        arr[arr.indexOf(letter.toLowerCase()) + 13]
    }

    console.log(rot13('Grfg'));
    console.log(rot13(' 10+2 is twelve.'));

    // Adding Big Numbers
    
    // We need to sum big numbers and we require your help.

    //     Write a function that returns the sum of two numbers.The input numbers are strings and the function must return a string.
    //         Example

    //     add("123", "321"); -> "444"
    //     add("11", "99"); -> "110"

    //     Notes

    //     The input numbers are big.
    //     The input is a string of only digits
    //     The numbers are positives

    const add = (param1, param2) => {
        const num1 = Number (param1);
        const num2 = Number (param2);
        let length;
        if (param1.length > param2.length) {
            length = param1.length;
        }
        else length = param2.length;
        console.log(length);
        let carryOverNum = 0;
        let finalNum = [];

        for (i = 0; i <= length; i++) {
            let sum = (Number (param1[i]) + Number(param2[i]) + Number(carryOverNum)).toString();
            if (sum.length > 1) {
                (sum.length > 2) ? carryOverNum = sum[0] + sum[1] + '0' : carryOverNum = sum[0] + '0';
                finalNum.push(sum[1]);
            }
            else finalNum.push(sum[0]);
            console.log(carryOverNum, i);
        }

        return finalNum.join('');
    }

    console.log(add('63829983432984289347293874', '90938498237058927340892374089'));
    

    // Given the object below, how would you go about finding the key that has the highest value ?

    const locations = {
        park: 10,
        forest: 1,
        mountains: 14,
        beach: 4,
        indoors: 7
    }

    const highestValue = (obj) => {
        const sortedNumber = Object.values(obj).sort((a,b) => b - a)[0];

        for (value in obj) {
            console.log(obj[value]);
            if (obj[value] === sortedNumber) {
                return value
            }
        }
    }

    const findHighest = (obj) => {
        return Object.keys(obj).sort((a, b) => obj[b] - obj[a])[0]
    }

    console.log(highestValue(locations));
    console.log(findHighest(locations));

    const isArray = (arr1, arr2) => {
        const mappedArr = arr1.map((value, index) => {
            if (typeof arr1[index] === typeof arr2[index]) {
                return arr2[index];
            }
            if (typeof arr1[index] === 'object' && typeof arr2[index] === 'object') {
                return arr1[index].length > arr2[index].length ? arr1[index].length : arr2[index].length;
            }
        })
        return mappedArr.length === arr1.length ? true : false;
    }

    console.log(isArray([[1, 4], 3, 4], [[1, 5], 4, 92]));
    console.log(isArray([[], []], [1, []]));


    //TOTAL MINUTES
    // Return the number of minutes between two dates

    const totalMinutes = (date1, date2) => {
        const minutes1 = date1.getTime();
        const minutes2 = date2.getTime();


        return minutes1 > minutes2 
        ? 
        (minutes1 - minutes2) / 60000 
        : 
        (minutes2 - minutes1) / 60000;
    }

    console.log(totalMinutes(new Date(2005, 11, 12), new Date(2006, 11, 12)));
    console.log(totalMinutes(new Date(2019, 11, 12), new Date(1993, 11, 12)));


    //CONVENIENCE STORE
    //Return a boolean if the amount of change in your pocket is enough to cover the cost of the item
    const convenienceChange = (change, cost) => {
        const changeValues = [.25, .1, .05, .01];
        const totalChange = change
        .map((quantity, index) => {
            return quantity * changeValues[index];
        })
        .reduce((a, b) => {
            return a + b
        }, 0);
        return totalChange > cost ? true : false;
    }

    console.log(convenienceChange([4, 2, 2, 0], 0));
    console.log(convenienceChange([8, 40, 9, 0], 3));

//     Barbecue Skewers

//         You are in charge of the barbecue grill.A vegetarian skewer is a skewer that has only vegetables(-o).A non - vegetarian skewer is a skewer with at least one piece of meat(-x).

//         For example, the grill below has 4 non - vegetarian skewers and 1 vegetarian skewer(the one in the middle).

//             ["--xo--x--ox--",
//             "--xx--x--xx--",
//             "--oo--o--oo--",
//             "--xx--x--ox--",
//             "--xx--x--ox--"]

//         Given a BBQ grill, write a function that returns[# vegetarian skewers, # non - vegarian skewers].For example above, the function should return [1, 4].
//             Examples

//          bbqSkewers([
//             "--oooo-ooo--",
//             "--xx--x--xx--",
//             "--o---o--oo--",
//             "--xx--x--ox--",
//             "--xx--x--ox--"
//          ]) ➞[2, 3]

//          bbqSkewers([
//             "--oooo-ooo--",
//             "--xxxxxxxx--",
//             "--o---",
//             "-o-----o---x--",
//             "--o---o-----"
//          ]) ➞[3, 2]

    const bbqSkewers = (arr) => { 
        let countArr = [0, 0];
        arr
        .forEach(skewer => {
            if(skewer.indexOf('x') === -1) {
                return countArr[0]++;
                }
            else {
                return countArr[1]++;
                }
            }
        )
        return countArr;
    }

    console.log(
        bbqSkewers([
            "--oooo-ooo--",
            "--xx--x--xx--",
            "--o---o--oo--",
            "--xx--x--ox--",
            "--xx--x--ox--"
        ])
    );
    console.log(bbqSkewers(
            ["--oooo-ooo--",
                "--ooooooo--",
                "--o---",
                "-o-----o---x--",
                "--o-oooo-----"]
        ));

    // Return the Objects Keys and Values

    // Create a function that takes an object and returns the keys and values as separate arrays.
    // Examples

    // keysAndValues({ a: 1, b: 2, c: 3 })
    // ➞ [["a", "b", "c"], [1, 2, 3]]

    // keysAndValues({ a: "Apple", b: "Microsoft", c: "Google" })
    // ➞ [["a", "b", "c"], ["Apple", "Microsoft", "Google"]]

    // keysAndValues({ key1: true, key2: false, key3: undefined })
    // ➞ [["key1", "key2", "key3"], [true, false, undefined]]

    const keysAndValues = (obj) => {
        return [Object.keys(obj), Object.values(obj)];
    }

    console.log(keysAndValues({a:1, b:2, c:3}));
    console.log(keysAndValues({ a: "Apple", b: "Microsoft", c: "Google" }));

    // Xs and Os, Nobody Knows

    //     Create a function that takes a string, checks if it has the same number of x's and o's and returns either true or false.

    //     Return a boolean value(true or false).
    //     The string can contain any character.
    //     When no x and no o are in the string, return true.

    //         Examples

    //     XO("ooxx") ➞ true

    //     XO("xooxx") ➞ false

    //     XO("ooxXm") ➞ true
    //     // Case insensitive.

    //     XO("zpzpzpp") ➞ true
    //     // Returns true if no x and o.

    //     XO("zzoo") ➞ false

    //     Notes

    //     Remember to return true if there aren't any x's or o's.
    //     Must be case insensitive.

    const XO = (str) => {
        const countObj = {};
        [...str.toLowerCase()].forEach(letter => {
            if (letter === 'x' || letter === 'o') {
                countObj[letter] ? countObj[letter]++ : countObj[letter] = 1;
            }
        })
        return countObj.x === countObj.o ? true : false;
    }

    console.log(XO('xxoo'));
    console.log(XO("zzoo"));
    console.log(XO("zpzpzpp"));
    console.log(XO("ooxXm"));

    const hackerSpeak = (str) => {
        return str.split('').map(letter => {
            if (letter === 'a') {
                return '4';
            } else if (letter === 'e') {
                return '3';
            } else if (letter === 'i') {
                return '1';
            } else if (letter === 'o') {
                return '0';
            } else if (letter === 's') {
                return '5';
            } else return letter;
        }).join('');
    }

    console.log(hackerSpeak('javascript is cool'));

    const convertToArray = (obj) => {
        const array = []
        for (item in obj) {
            array.push([item, obj[item]])
        }
        return array;
    }

    console.log(convertToArray({ a: 1, b: 2 }));
    console.log(convertToArray({ shrimp: 15, tots: 12 }));

    const linesAreParallel = (arr1, arr2) => {
        return arr1[1] / arr1[0] === arr2[1] / arr2[0] ? true : false;
    }
    
    console.log(linesAreParallel([2, 4, 6], [4, 8, 12]));
    console.log(linesAreParallel([2, 4, 1], [4, 2, 1]));

    // The Museum of Incredibly DULL Things

    //     A museum wants to get rid of some exhibitions.Katya, the interior architect, comes up with a plan to remove the most boring exhibitions.She gives them a rating, and removes the one with the lowest rating.Just as she finishes rating the exhibitions, she's called off to an important meeting. She asks you to write a program that tells her the ratings of the items after the lowest one is removed.

    //     Create a function that takes an array of integers and removes the smallest value.
    //         Examples

    //     removeSmallest([1, 2, 3, 4, 5]) ➞[2, 3, 4, 5]

    //     removeSmallest([5, 3, 2, 1, 4]) ➞[5, 3, 2, 4]

    //     removeSmallest([2, 2, 1, 2, 1]) ➞[2, 2, 2, 1]

    //     Notes

    //     Don't change the order of the left over items.
    //     If you get an empty array, return an empty array: []➞[].
    //     If there are multiple items with the same value, remove item with lower index(3rd example).

    const removeSmallest = (arr) => {
        const junkArr = []
        return arr.filter(number => {
            if (number === 1 && junkArr.length === 0) {
                junkArr.push(number);
            } else {
                return number
            }
        })
    }

    console.log(removeSmallest([2, 2, 1, 2, 1]));
    console.log(removeSmallest([5, 3, 2, 1, 4]));

    // Seven Boom!

    //     Create a function that takes an array of numbers and return "Boom!" if the number 7 appears in the array.Otherwise, return "there is no 7 in the array".
    //         Examples

    //     sevenBoom([1, 2, 3, 4, 5, 6, 7]) ➞ "Boom!"

    //     sevenBoom([8, 6, 33, 100]) ➞ "there is no 7 in the array"

    //     sevenBoom([2, 55, 60, 97, 86]) ➞ "Boom!"

    const sevenBoom = (arr) => {
        return arr
            .map(number => number.toString())
            .map(str => str.includes(7) ? true : false)
            .includes(true);
    }

    console.log(sevenBoom([1, 2, 3, 4, 5, 6, 7]));
    console.log(sevenBoom([8, 6, 33, 100]));
    console.log(sevenBoom([2, 55, 60, 97, 86]));

    // Book Shelf

    //     Create a Book constructor that has two properties:

    //     Title
    //     Author

    //     and two methods:

    //     A method named getTitle that returns: "Title: " + the instance title.
    //     A method named getAuthor that returns: "Author: " + the instance author.

    //     and instantiate this constructor by creating 3 new books:

    //     Pride and Prejudice - Jane Austen(PP)
    //     Hamlet - William Shakespeare(H)
    //     War and Peace - Leo Tolstoy(WP)

    //     Name the new object instances PP, H, and WP, respectively.

    //     For instance, if I instantiated the following book using this Book constructor function:

    //         Harry Potter - J.K.Rowling(HP)

    //     I would get the following properties and methods:

        // HP.title ➞ "Harry Potter"

        //     HP.author ➞ "J.K. Rowling"

        //     HP.getTitle() ➞ "Title: Harry Potter"

        //     HP.getAuthor() ➞ "Author: J.K. Rowling"

        class Book {
            constructor(title = 'test', author = 'another test') {
                this.title = title;
                this.author = author;
                this.getTitle = function () {
                    return "Title: " + this.title;
                };
                this.getAuthor = function () {
                    return "Author: " + this.author;
                };
            }
        }

        const PP = new Book('Pride and Prejudice', "Jane Austen");
        const H = new Book ('Hamlet', "William Shakespeare");
        const WP = new Book ('War and Peace', 'Leo Tolstoy');
        
        WP.date = 'December 8th';

        console.log(PP.title, PP.author, PP.getTitle(), PP.getAuthor());
        console.log(H.title, H.author, H.getTitle(), H.getAuthor());
        console.log(WP.title, WP.author, WP.getTitle(), WP.getAuthor());
        console.log(WP);
        console.log(new Book());

        // Calculate the Total Price of Groceries

        //     Create a function that takes an array of objects(groceries) which calculates the total price and returns it as a number.A grocery object has a product, a quantity and a price, for example:

        //         {
        //             "product": "Milk",
        //                 "quantity": 1,
        //                     "price": 1.50
        //         }

        //     Examples

        //     // 1 bottle of milk:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 }
        //     ]) ➞ 1.5

        //     // 1 bottle of milk & 1 box of cereals:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 },
        //         { product: "Cereals", quantity: 1, price: 2.50 }
        //     ]) ➞ 4

        //     // 3 bottles of milk:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 3, price: 1.50 }
        //     ]) ➞ 4.5

        //     // Several groceries:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 },
        //         { product: "Eggs", quantity: 12, price: 0.10 },
        //         { product: "Bread", quantity: 2, price: 1.60 },
        //         { product: "Cheese", quantity: 1, price: 4.50 }
        //     ]) ➞ 10.4

        //     // Some cheap candy:
        //     getTotalPrice([
        //         { product: "Chocolate", quantity: 1, price: 0.10 },
        //         { product: "Lollipop", quantity: 1, price: 0.20 }
        //     ]) ➞ 0.3

        const groceries = [
            { product: "Milk", quantity: 1, price: 1.50 },
            { product: "Eggs", quantity: 12, price: 0.10 },
            { product: "Bread", quantity: 2, price: 1.60 },
            { product: "Cheese", quantity: 1, price: 4.50 }
        ]
        const groceries2 = [
            { product: "Chocolate", quantity: 1, price: 0.10 },
            { product: "Lollipop", quantity: 1, price: 0.20 }
        ]
        const groceries3 = [
            { product: "Milk", quantity: 1, price: 1.50 },
            { product: "Cereals", quantity: 1, price: 2.50 }
        ]

        const getTotalPrice = (arr) => {
            return parseFloat(
                arr.map(item => item.price * item.quantity)
                    .reduce((a, b) => a + b).toFixed(1)
            );
        }

        console.log(getTotalPrice(groceries));
        console.log(getTotalPrice(groceries2));
        console.log(getTotalPrice(groceries3));
</script>
</body>
</html>