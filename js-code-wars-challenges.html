<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Code-Wars Daily Challenges</title>
</head>
<body>
<script>
    // Your task is to convert strings to how they would be written by Jaden Smith.The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

    //         Example:

    //     Not Jaden - Cased: "How can mirrors be real if our eyes aren't real"
    //     Jaden - Cased: "How Can Mirrors Be Real If Our Eyes Aren't Real"

    const jadenCased = (str) => {
        const array = str.split(' ');
        let finalArray = [];
        for (word of array) {
            const uppercaseArray = [...word];
            let uppercaseLetter = uppercaseArray[0].toUpperCase();
            uppercaseArray.shift();
            uppercaseArray.unshift(uppercaseLetter);
            const jadenCasedWord = uppercaseArray.join('');  
            finalArray.push(jadenCasedWord);
        }
        const jadenCasedSentence = finalArray.join(' ');
        return console.log(jadenCasedSentence);
    }

    jadenCased("How can mirrors be real if our eyes aren't real");


    //Descending Order
    // Your task is to make a function that can take any non - negative integer as a argument and return it with its digits in descending order.Essentially, rearrange the digits to create the highest possible number.
    //         Examples:

    //     Input: 21445 Output: 54421

    //     Input: 145263 Output: 654321

    //     Input: 1254859723 Output: 9875543221

    const descendingOrder = number => {
        if (typeof number != 'number') {
            return console.log('put in a number ya fool!');
        }

        const numberStr = number.toString();
        const numberArray = [...numberStr];
        const sortedNumberArray = numberArray.sort();
        let reverseSortedArray = [];
        for (value of sortedNumberArray) {
            reverseSortedArray.unshift(value);
        }

        reverseNumberStr = reverseSortedArray.join('');
        const reverseNumber = Number(reverseNumberStr);
        return reverseNumber;
    }

    descendingOrder(21445);
    descendingOrder(123456789);
    descendingOrder(1021);


    //Isogram
    
    // An isogram is a word that has no repeating letters, consecutive or non - consecutive.Implement a function that determines whether a string that contains only letters is an isogram.Assume the empty string is an isogram.Ignore letter case.

    //     isIsogram("Dermatoglyphics") == true
    //     isIsogram("aba") == false
    //     isIsogram("moOse") == false // -- ignore letter case

    const isIsogram = str => {
        const lowerCaseStr = str.toLowerCase();
        const strArray = [...lowerCaseStr];
        let letterCount = {};

        for (letter of strArray) {
            if (letterCount[letter] === undefined) {
                letterCount[letter] = 1;
            }
            else {
                letterCount[letter]++
                return console.log(false);
            }
        }

        return console.log(true);
    }

    isIsogram('the');
    isIsogram('aba');
    isIsogram('moOse');

//   Funny string attachment  

// This time no story, no theory. The examples below show you how to write function accum:

// Examples:

// accum("abcd") -> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt") -> "C-Ww-Aaa-Tttt"

// The parameter of accum is a string which includes only letters from a..z and A..Z.

    const strAccum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        let newArray = [];

        for (let i = 0; i <= strArray.length - 1; i++) {
            if (i === 0) {
                const firstLetter = strArray[i];
                newArray.push(firstLetter + '-');
            }
            else if(i > 0 && i < strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i) + '-');
            }
            else if (i === strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i));
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(strAccum('abcd'));
    console.log(strAccum('cwAT'));

    const accum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        const newArray = strArray.map((letter, i) => {
            return letter + letter.toLowerCase().repeat(i);
        });
        const finalStr = newArray.join('-');
        return finalStr;
    }

    console.log(accum('abcd'));
    console.log(accum('cwAT'));

    // Given: an array containing hashes of names

    //     Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.

    //         Example:

    //     list([{ name: 'Bart' }, { name: 'Lisa' }, { name: 'Maggie' }])
    //     // returns 'Bart, Lisa & Maggie'

    //     list([{ name: 'Bart' }, { name: 'Lisa' }])
    //     // returns 'Bart & Lisa'

    //     list([{ name: 'Bart' }])
    //     // returns 'Bart'

    //     list([])
// returns ''

    const arrayList = [{name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'}];

    const list = array => {
            let newArray = [];
            for (obj of array) {
                newArray.push(obj.name);
            }
            const finalStr = newArray.map((name, i) => {
                if ((newArray.length - 1) === 0) {
                    return name;
                }
                else if (i === (newArray.length - 1)) {
                    return '& ' + name;
                }
                else if (i === (newArray.length - 2)) {
                    return name;
                }
                return name + ','
            }).join(' ');
            
            return finalStr;
    }

    console.log(list(arrayList)); 


    // Array Diff
    // Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

    //     It should remove all values from list a, which are present in list b.

    //         array_diff([1, 2], [1]) == [2]

    //     If a value is present in b, all of its occurrences must be removed from the other:

    //     array_diff([1, 2, 2, 2, 3], [2]) == [1, 3]

    const array_diff = (array1, array2) => {
        return array1.filter(item => {
            //very interesting quirk here with .filter() method, it doesn't return values of 0 in an array
            //this is because the value of 0 returns falsy, so filter doesn't recognize it and therefore doesn't return it in the new array
            return !array2.includes(item);
        })
    }

    console.log(array_diff([1, 2, 2, 2, 3, 0], [2]));



    // Write a function using recursion that takes a base and an exponent and outputs the power.

    //     e.g.

    //     power(2, 3) -> 8

    // power(4, 2) -> 16


    const power = (base, exponent) => {
        if (exponent <= 1) {
            return base
        }
        else {
            return base * power(base, exponent - 1);
        }
    }


    console.log(power(2, 3));
    console.log(power(4, 2));



    // Write a function that takes two arrays and returns their intersection as an array.

    //     intersection([1, 2, 3], [2, 3, 4]) -> [2, 3]

    // intersection([a, 1, 'foo'], ['foo', 17, a]) -> [a, 'foo']

    const intersection = (array1, array2) => {
        return array1.filter(item => {
            return array2.includes(item);
        })
    }

    console.log(intersection([1, 2, 3], [2, 3, 4]));
    console.log(intersection(['a', 1, 'foo'], ['foo', 17, 'a']));




    // Write a function that weaves 2 strings together.If one string is longer than the other, attach all letters left at the end.

    //     weave('abc', '123') -> 'a1b2c3'

    // weave('abcdefg', '123') -> 'a1b2c3defg'

    const weave = (str1, str2) => {
        const str1Array = [...str1];
        const str2Array = [...str2];
        let newArray = [];
        let length;

        if (str1Array.length - 1 > str2Array.length - 1) {
            length = str1Array.length - 1;
        }
        else {
            length = str2Array.length - 1;
        }

        for (let i = 0; i <= length; i++) {
            if (str1Array[i]){
                newArray.push(str1Array[i]);
            }
            if (str2Array[i]) {
                newArray.push(str2Array[i]);
            }
        }

        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(weave('abc', '123')); 
    console.log(weave('abcdefg', '123'));


    // Convert seconds to time format 
    
    // Write a function, which takes a non - negative integer(seconds) as input and returns the time in a human - readable format(HH: MM: SS)

    //     HH = hours, padded to 2 digits, range: 00 - 99
    //     MM = minutes, padded to 2 digits, range: 00 - 59
    //     SS = seconds, padded to 2 digits, range: 00 - 59

    //     The maximum time never exceeds 359999(99: 59: 59)

    //     You can find some examples in the test fixtures.

    const humanReadable = (secs) => {
        let seconds;

        let minutes = Math.floor(secs / 60).toString();
        let hours = Math.floor(secs / 3600).toString();
        seconds = (secs % 60).toString();
        
        if (hours >= 1) {
            minutes = (minutes % 60).toString();
        }
        if (hours >= 99) {
            hours = 99;
        }
        if (hours >= 0 && hours < 10) {
            hours = '0' + hours;
        }
        if (minutes >= 0 && minutes < 10) {
            minutes = '0' + minutes;
        }
        if (seconds >= 0 && seconds < 10) {
            seconds = '0' + seconds;
        }

        console.log(seconds);
        return `${hours}:${minutes}:${seconds}`;
    }

    console.log(humanReadable(1000));
    console.log(humanReadable(5));
    console.log(humanReadable(60));
    console.log(humanReadable(86399));
    console.log(humanReadable(359999));
    console.log(humanReadable(45296));

    const humanReadable2 = (time) => {
        //very interesting solution here
        //parseInt() will drop the decimal values on the number when converting to string
        const hours = parseInt(time / 3600);
        const minutes = parseInt(time / 60) % 60;
        const seconds = time % 60;
        //that gives us all of the values we needs

        const pad = (val) => {
            //this function creates the values we need for our final string
            //in a patterned fashion
            return val < 10 ? "0" + val : val;
        }

        return pad(hours) + ":" + pad(minutes) + ":" + pad(seconds);
    }

    //Write a function that counts the letters of multiple string values in an array
    //Then, return the letter count for each individual string as an object
    //Each object's letter count will be stored in an array to be returned by the function

    const countLetters = (array) => {
        let obj = {};
        let finalArray = [];

        for (word of array) {
            obj = {}
            let strArray = [...word];
            for (letter of strArray) {
                if (obj[letter] === undefined) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++
                }
            }
            finalArray.push(obj);
        }
        return finalArray;
    }

    console.log(countLetters(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    const countLetters2 = array => {
        return array.map(string => {
            const obj = {};
            [...string].map(letter => {
                if (!obj[letter]) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++;
                }
            })
            return obj
        })
    }

    console.log(countLetters2(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    //Find Int
    
    // Given an array, find the int that appears an odd number of times.

    //     There will always be only one integer that appears an odd number of times.

    const findOdd = (array) => {
        const obj = {}
        array.map(number => {
            if (!obj[number]) {
                obj[number] = 1;
            }
            else {
                obj[number]++;
            }
        })
        for (key in obj) {
            if (obj[key] % 2 !== 0) {
                return Number(key);
            }
        }
    }
    

    console.log(findOdd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    const findOdd2 = (xs) => xs.reduce((a, b) => a ^ b);

    console.log(findOdd2([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    console.log([ 1, 1, 2, 7, 2, 3, 3].reduce((a,b) => a ^ b));


    // A Narcissistic Number is a number which is the sum of its own digits, each raised to the power of the number of digits in a given base.In this Kata, we will restrict ourselves to decimal(base 10).

//     For example, take 153(3 digits):

//     1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 1 + 125 + 27 = 153

//     and 1634(4 digits):

//     1 ^ 4 + 6 ^ 4 + 3 ^ 4 + 4 ^ 4 = 1 + 1296 + 81 + 256 = 1634

//     The Challenge:

//     Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

//     Error checking for text strings or other invalid inputs is not required, only valid integers will be passed into the function.

    const narcissistic = num => {
        const numStr = `${num}`
        const numArray = [...numStr];
        const length = numArray.length;

        const finalSum = numArray
        .map(number =>  number ** length)
        .reduce((a,b) => a + b);

        if (finalSum === num) return true;
        else return false;
    }

    console.log(narcissistic(7));
    console.log(narcissistic(371));

    // Three conditions must be met for a valid experiment:

    //         Float parameter "h" in meters must be greater than 0
    //     Float parameter "bounce" must be greater than 0 and less than 1
    //     Float parameter "window" must be less than h.

    //     If all three conditions above are fulfilled, return a positive integer, otherwise return -1.
    //     Note:

    //     The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.

    const bouncingBalls = (h, b, w) => {
        const height = h > 0;
        const bounce = b < 1 && b > 0;
        const windowHeight = w < h;

        if (height && bounce && windowHeight) {
            let count = 1;
            let bounceHeight = b * h;

            for (i = bounceHeight; i > w; i *= b) {
                count = count + 2;
            }
            return count;
        }
        else return -1;
    }

    console.log(bouncingBalls(3, .66, 1.5));
    console.log(bouncingBalls(30, .66, 1.5));

    // Complete the method / function so that it converts dash / underscore delimited words into camel casing.The first word within the output should be capitalized only if the original word was capitalized(known as Upper Camel Case, also often referred to as Pascal case).
    //         Examples

    //     toCamelCase("the-stealth-warrior") // returns "theStealthWarrior"

    //     toCamelCase("The_Stealth_Warrior") // returns "TheStealthWarrior"

    // const toCamelCase = (str) => {
    //     if (str === '') return 
        
    //     const strArray = str.split(/[-_]+/g);
        
    //     const newArray = strArray.map(word => {
    //         if (word === strArray[0] && strArray[0] === strArray[0].toLowerCase()) {
    //             return word.replace(word[0], word[0].toLowerCase())
    //         }
    //         else {
    //             return word.replace(word[0], word[0].toUpperCase());
    //         }
    //     })  
    //     return newArray.join('');
    // }


    const toCamelCase = (str) => {
        const regExp = /[-_]\w/ig;
        return str.replace(regExp, (match) => {
            return match.charAt(1).toUpperCase();
        });
    }

    console.log(toCamelCase('the-stealth-warrior'));
    console.log(toCamelCase("The_Stealth_Warrior"));

    // Write a function that accepts an array of 10 integers(between 0 and 9), that returns a string of those numbers in the form of a phone number.
    //         Example:

    //     createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"

    //     The returned format must be correct in order to complete this challenge.
    //         Don't forget the space after the closing parenthesis!

    const createPhoneNumber = (array) => {
        return array.map((number, index) => {
            if (index === 0){
                return `(${number}`;
            }
            if (index === 2) {
                return `${number})`;
            }
            if (index === 3) {
                return ` ${number}`
            }
            if (index === 5) {
                return `${number}-`
            }
            return number;
        }).join('');
    }

    console.log(createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]));

    // The marketing team is spending way too much time typing in hashtags.
    //         Let's help them with our own Hashtag Generator!

    //     Here's the deal:

    //     It must start with a hashtag(#).
    //     All words must have their first letter capitalized.
    //     If the final result is longer than 140 chars it must return false.
    //     If the input or the result is an empty string it must return false.

    const generateHashtag = (str) => {
        if (str === '') return false;
        if (str.length >= 140) return false;
        const strArray = str.split(' ');
        strArray.unshift('#')
        let newArray = [];
        for (word of strArray) {
            if (word != '') {
                const lowerCase = word.charAt(0);
                const upperCase = word.charAt(0).toUpperCase();
                const newWord = word.replace(lowerCase, upperCase);
                newArray.push(newWord);
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(generateHashtag('hello        World'));
    console.log(generateHashtag(' Hello there thanks for trying my Kata'));

    // ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters after it in the alphabet.ROT13 is an example of the Caesar cipher.

    //     Create a function that takes a string and returns the string ciphered with Rot13.If there are numbers or special characters included in the string, they should be returned as they are.Only letters from the latin / english alphabet should be shifted, like in the original Rot13 "implementation".

    const rot13 = (str) => {
        const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        const strArray = [...str];
        const regex = /[\W\d0\s]/g;
        return strArray.map((letter, index) => {
            if (regex.test(letter)){
                console.log(regex.test(letter));
                return letter;
            }
            else if (letter === letter.toUpperCase()){
                return checkLetterPosition(alphabet, letter).toUpperCase();
            }
            else return checkLetterPosition(alphabet, letter);
        }).join('');
    }

    const checkLetterPosition = (arr, letter) => {
        return (arr.indexOf(letter.toLowerCase()) > 12)
        ?
        arr[12 - ((arr.length - 1) - arr.indexOf(letter.toLowerCase()))]
        :
        arr[arr.indexOf(letter.toLowerCase()) + 13]
    }

    console.log(rot13('Grfg'));
    console.log(rot13(' 10+2 is twelve.'));

    // Adding Big Numbers
    
    // We need to sum big numbers and we require your help.

    //     Write a function that returns the sum of two numbers.The input numbers are strings and the function must return a string.
    //         Example

    //     add("123", "321"); -> "444"
    //     add("11", "99"); -> "110"

    //     Notes

    //     The input numbers are big.
    //     The input is a string of only digits
    //     The numbers are positives

    const add = (param1, param2) => {
        const num1 = Number (param1);
        const num2 = Number (param2);
        let length;
        if (param1.length > param2.length) {
            length = param1.length;
        }
        else length = param2.length;
        console.log(length);
        let carryOverNum = 0;
        let finalNum = [];

        for (i = 0; i <= length; i++) {
            let sum = (Number (param1[i]) + Number(param2[i]) + Number(carryOverNum)).toString();
            if (sum.length > 1) {
                (sum.length > 2) ? carryOverNum = sum[0] + sum[1] + '0' : carryOverNum = sum[0] + '0';
                finalNum.push(sum[1]);
            }
            else finalNum.push(sum[0]);
            console.log(carryOverNum, i);
        }

        return finalNum.join('');
    }

    console.log(add('63829983432984289347293874', '90938498237058927340892374089'));
    

    // Given the object below, how would you go about finding the key that has the highest value ?

    const locations = {
        park: 10,
        forest: 1,
        mountains: 14,
        beach: 4,
        indoors: 7
    }

    const highestValue = (obj) => {
        const sortedNumber = Object.values(obj).sort((a,b) => b - a)[0];

        for (value in obj) {
            console.log(obj[value]);
            if (obj[value] === sortedNumber) {
                return value
            }
        }
    }

    const findHighest = (obj) => {
        return Object.keys(obj).sort((a, b) => obj[b] - obj[a])[0]
    }

    console.log(highestValue(locations));
    console.log(findHighest(locations));

    const isArray = (arr1, arr2) => {
        const mappedArr = arr1.map((value, index) => {
            if (typeof arr1[index] === typeof arr2[index]) {
                return arr2[index];
            }
            if (typeof arr1[index] === 'object' && typeof arr2[index] === 'object') {
                return arr1[index].length > arr2[index].length ? arr1[index].length : arr2[index].length;
            }
        })
        return mappedArr.length === arr1.length ? true : false;
    }

    console.log(isArray([[1, 4], 3, 4], [[1, 5], 4, 92]));
    console.log(isArray([[], []], [1, []]));


    //TOTAL MINUTES
    // Return the number of minutes between two dates

    const totalMinutes = (date1, date2) => {
        const minutes1 = date1.getTime();
        const minutes2 = date2.getTime();


        return minutes1 > minutes2 
        ? 
        (minutes1 - minutes2) / 60000 
        : 
        (minutes2 - minutes1) / 60000;
    }

    console.log(totalMinutes(new Date(2005, 11, 12), new Date(2006, 11, 12)));
    console.log(totalMinutes(new Date(2019, 11, 12), new Date(1993, 11, 12)));


    //CONVENIENCE STORE
    //Return a boolean if the amount of change in your pocket is enough to cover the cost of the item
    const convenienceChange = (change, cost) => {
        const changeValues = [.25, .1, .05, .01];
        const totalChange = change
        .map((quantity, index) => {
            return quantity * changeValues[index];
        })
        .reduce((a, b) => {
            return a + b
        }, 0);
        return totalChange > cost ? true : false;
    }

    console.log(convenienceChange([4, 2, 2, 0], 0));
    console.log(convenienceChange([8, 40, 9, 0], 3));

//     Barbecue Skewers

//         You are in charge of the barbecue grill.A vegetarian skewer is a skewer that has only vegetables(-o).A non - vegetarian skewer is a skewer with at least one piece of meat(-x).

//         For example, the grill below has 4 non - vegetarian skewers and 1 vegetarian skewer(the one in the middle).

//             ["--xo--x--ox--",
//             "--xx--x--xx--",
//             "--oo--o--oo--",
//             "--xx--x--ox--",
//             "--xx--x--ox--"]

//         Given a BBQ grill, write a function that returns[# vegetarian skewers, # non - vegarian skewers].For example above, the function should return [1, 4].
//             Examples

//          bbqSkewers([
//             "--oooo-ooo--",
//             "--xx--x--xx--",
//             "--o---o--oo--",
//             "--xx--x--ox--",
//             "--xx--x--ox--"
//          ]) ➞[2, 3]

//          bbqSkewers([
//             "--oooo-ooo--",
//             "--xxxxxxxx--",
//             "--o---",
//             "-o-----o---x--",
//             "--o---o-----"
//          ]) ➞[3, 2]

    const bbqSkewers = (arr) => { 
        let countArr = [0, 0];
        arr
        .forEach(skewer => {
            if(skewer.indexOf('x') === -1) {
                return countArr[0]++;
                }
            else {
                return countArr[1]++;
                }
            }
        )
        return countArr;
    }

    console.log(
        bbqSkewers([
            "--oooo-ooo--",
            "--xx--x--xx--",
            "--o---o--oo--",
            "--xx--x--ox--",
            "--xx--x--ox--"
        ])
    );
    console.log(bbqSkewers(
            ["--oooo-ooo--",
                "--ooooooo--",
                "--o---",
                "-o-----o---x--",
                "--o-oooo-----"]
        ));

    // Return the Objects Keys and Values

    // Create a function that takes an object and returns the keys and values as separate arrays.
    // Examples

    // keysAndValues({ a: 1, b: 2, c: 3 })
    // ➞ [["a", "b", "c"], [1, 2, 3]]

    // keysAndValues({ a: "Apple", b: "Microsoft", c: "Google" })
    // ➞ [["a", "b", "c"], ["Apple", "Microsoft", "Google"]]

    // keysAndValues({ key1: true, key2: false, key3: undefined })
    // ➞ [["key1", "key2", "key3"], [true, false, undefined]]

    const keysAndValues = (obj) => {
        return [Object.keys(obj), Object.values(obj)];
    }

    console.log(keysAndValues({a:1, b:2, c:3}));
    console.log(keysAndValues({ a: "Apple", b: "Microsoft", c: "Google" }));

    // Xs and Os, Nobody Knows

    //     Create a function that takes a string, checks if it has the same number of x's and o's and returns either true or false.

    //     Return a boolean value(true or false).
    //     The string can contain any character.
    //     When no x and no o are in the string, return true.

    //         Examples

    //     XO("ooxx") ➞ true

    //     XO("xooxx") ➞ false

    //     XO("ooxXm") ➞ true
    //     // Case insensitive.

    //     XO("zpzpzpp") ➞ true
    //     // Returns true if no x and o.

    //     XO("zzoo") ➞ false

    //     Notes

    //     Remember to return true if there aren't any x's or o's.
    //     Must be case insensitive.

    const XO = (str) => {
        const countObj = {};
        [...str.toLowerCase()].forEach(letter => {
            if (letter === 'x' || letter === 'o') {
                countObj[letter] ? countObj[letter]++ : countObj[letter] = 1;
            }
        })
        return countObj.x === countObj.o ? true : false;
    }

    console.log(XO('xxoo'));
    console.log(XO("zzoo"));
    console.log(XO("zpzpzpp"));
    console.log(XO("ooxXm"));

    const hackerSpeak = (str) => {
        return str.split('').map(letter => {
            if (letter === 'a') {
                return '4';
            } else if (letter === 'e') {
                return '3';
            } else if (letter === 'i') {
                return '1';
            } else if (letter === 'o') {
                return '0';
            } else if (letter === 's') {
                return '5';
            } else return letter;
        }).join('');
    }

    console.log(hackerSpeak('javascript is cool'));

    const convertToArray = (obj) => {
        const array = []
        for (item in obj) {
            array.push([item, obj[item]])
        }
        return array;
    }

    console.log(convertToArray({ a: 1, b: 2 }));
    console.log(convertToArray({ shrimp: 15, tots: 12 }));

    const linesAreParallel = (arr1, arr2) => {
        return arr1[1] / arr1[0] === arr2[1] / arr2[0] ? true : false;
    }
    
    console.log(linesAreParallel([2, 4, 6], [4, 8, 12]));
    console.log(linesAreParallel([2, 4, 1], [4, 2, 1]));

    // The Museum of Incredibly DULL Things

    //     A museum wants to get rid of some exhibitions.Katya, the interior architect, comes up with a plan to remove the most boring exhibitions.She gives them a rating, and removes the one with the lowest rating.Just as she finishes rating the exhibitions, she's called off to an important meeting. She asks you to write a program that tells her the ratings of the items after the lowest one is removed.

    //     Create a function that takes an array of integers and removes the smallest value.
    //         Examples

    //     removeSmallest([1, 2, 3, 4, 5]) ➞[2, 3, 4, 5]

    //     removeSmallest([5, 3, 2, 1, 4]) ➞[5, 3, 2, 4]

    //     removeSmallest([2, 2, 1, 2, 1]) ➞[2, 2, 2, 1]

    //     Notes

    //     Don't change the order of the left over items.
    //     If you get an empty array, return an empty array: []➞[].
    //     If there are multiple items with the same value, remove item with lower index(3rd example).

    const removeSmallest = (arr) => {
        const junkArr = []
        return arr.filter(number => {
            if (number === 1 && junkArr.length === 0) {
                junkArr.push(number);
            } else {
                return number
            }
        })
    }

    console.log(removeSmallest([2, 2, 1, 2, 1]));
    console.log(removeSmallest([5, 3, 2, 1, 4]));

    // Seven Boom!

    //     Create a function that takes an array of numbers and return "Boom!" if the number 7 appears in the array.Otherwise, return "there is no 7 in the array".
    //         Examples

    //     sevenBoom([1, 2, 3, 4, 5, 6, 7]) ➞ "Boom!"

    //     sevenBoom([8, 6, 33, 100]) ➞ "there is no 7 in the array"

    //     sevenBoom([2, 55, 60, 97, 86]) ➞ "Boom!"

    const sevenBoom = (arr) => {
        return arr
            .map(number => number.toString())
            .map(str => str.includes(7) ? true : false)
            .includes(true);
    }

    console.log(sevenBoom([1, 2, 3, 4, 5, 6, 7]));
    console.log(sevenBoom([8, 6, 33, 100]));
    console.log(sevenBoom([2, 55, 60, 97, 86]));

    // Book Shelf

    //     Create a Book constructor that has two properties:

    //     Title
    //     Author

    //     and two methods:

    //     A method named getTitle that returns: "Title: " + the instance title.
    //     A method named getAuthor that returns: "Author: " + the instance author.

    //     and instantiate this constructor by creating 3 new books:

    //     Pride and Prejudice - Jane Austen(PP)
    //     Hamlet - William Shakespeare(H)
    //     War and Peace - Leo Tolstoy(WP)

    //     Name the new object instances PP, H, and WP, respectively.

    //     For instance, if I instantiated the following book using this Book constructor function:

    //         Harry Potter - J.K.Rowling(HP)

    //     I would get the following properties and methods:

        // HP.title ➞ "Harry Potter"

        //     HP.author ➞ "J.K. Rowling"

        //     HP.getTitle() ➞ "Title: Harry Potter"

        //     HP.getAuthor() ➞ "Author: J.K. Rowling"

        class Book {
            constructor(title = 'test', author = 'another test') {
                this.title = title;
                this.author = author;
                this.getTitle = function () {
                    return "Title: " + this.title;
                };
                this.getAuthor = function () {
                    return "Author: " + this.author;
                };
            }
        }

        const PP = new Book('Pride and Prejudice', "Jane Austen");
        const H = new Book ('Hamlet', "William Shakespeare");
        const WP = new Book ('War and Peace', 'Leo Tolstoy');
        
        WP.date = 'December 8th';

        console.log(PP.title, PP.author, PP.getTitle(), PP.getAuthor());
        console.log(H.title, H.author, H.getTitle(), H.getAuthor());
        console.log(WP.title, WP.author, WP.getTitle(), WP.getAuthor());
        console.log(WP);
        console.log(new Book());

        // Calculate the Total Price of Groceries

        //     Create a function that takes an array of objects(groceries) which calculates the total price and returns it as a number.A grocery object has a product, a quantity and a price, for example:

        //         {
        //             "product": "Milk",
        //                 "quantity": 1,
        //                     "price": 1.50
        //         }

        //     Examples

        //     // 1 bottle of milk:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 }
        //     ]) ➞ 1.5

        //     // 1 bottle of milk & 1 box of cereals:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 },
        //         { product: "Cereals", quantity: 1, price: 2.50 }
        //     ]) ➞ 4

        //     // 3 bottles of milk:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 3, price: 1.50 }
        //     ]) ➞ 4.5

        //     // Several groceries:
        //     getTotalPrice([
        //         { product: "Milk", quantity: 1, price: 1.50 },
        //         { product: "Eggs", quantity: 12, price: 0.10 },
        //         { product: "Bread", quantity: 2, price: 1.60 },
        //         { product: "Cheese", quantity: 1, price: 4.50 }
        //     ]) ➞ 10.4

        //     // Some cheap candy:
        //     getTotalPrice([
        //         { product: "Chocolate", quantity: 1, price: 0.10 },
        //         { product: "Lollipop", quantity: 1, price: 0.20 }
        //     ]) ➞ 0.3

        const groceries = [
            { product: "Milk", quantity: 1, price: 1.50 },
            { product: "Eggs", quantity: 12, price: 0.10 },
            { product: "Bread", quantity: 2, price: 1.60 },
            { product: "Cheese", quantity: 1, price: 4.50 }
        ]
        const groceries2 = [
            { product: "Chocolate", quantity: 1, price: 0.10 },
            { product: "Lollipop", quantity: 1, price: 0.20 }
        ]
        const groceries3 = [
            { product: "Milk", quantity: 1, price: 1.50 },
            { product: "Cereals", quantity: 1, price: 2.50 }
        ]

        const getTotalPrice = (arr) => {
            return parseFloat(
                arr.map(item => item.price * item.quantity)
                    .reduce((a, b) => a + b).toFixed(1)
            );
        }

        console.log(getTotalPrice(groceries));
        console.log(getTotalPrice(groceries2));
        console.log(getTotalPrice(groceries3));

        // Where's Waldo?

        // Return the coordinates([row, col]) of the element that differs from the rest.
        //     Examples

        // whereIsWaldo([
        //     ["A", "A", "A"],
        //     ["A", "A", "A"],
        //     ["A", "B", "A"]
        // ]) ➞[3, 2]

        // whereIsWaldo([
        //     ["c", "c", "c", "c"],
        //     ["c", "c", "c", "d"]
        // ]) ➞[2, 4]

        // whereIsWaldo([
        //     ["O", "O", "O", "O"],
        //     ["O", "O", "O", "O"],
        //     ["O", "O", "O", "O"],
        //     ["O", "O", "O", "O"],
        //     ["P", "O", "O", "O"],
        //     ["O", "O", "O", "O"]
        // ]) ➞[5, 1]

        // Notes

        // Rows and columns are 1 - indexed(not zero - indexed).

        //this was the function that I created and struggled to solve problem with
        // const whereIsWaldo = (arr) => {
        //     let commonLetter = '';
        //     return arr.map((list, index) => {
        //         let commonLetter;
        //         list.filter((letter, index2) => {
        //             if (list[index2] === list[index2 + 2]) {
        //                 commonLetter = list[index2];
        //             } else {
        //                 commonLetter = list[index2 + 1];
        //             }
        //             if (letter !== commonLetter) {
        //                 // return [index + 1, list.indexOf(letter) + 1];
        //             }
        //         })
        //     });
        // }

        const whereIsWaldo = (arr) => {
                let result;
                arr.filter((el, i) => el.find((a, index) =>
                    el.indexOf(a) == el.lastIndexOf(a) ? result = [i + 1, index + 1] : ""))
                return result
            }
        

        console.log(whereIsWaldo([
            ["c", "c", "c", "c"],
            ["c", "c", "c", "d"]
        ]));
        console.log(whereIsWaldo([
            ["O", "O", "O", "O"],
            ["O", "O", "O", "O"],
            ["O", "O", "O", "O"],
            ["O", "O", "O", "O"],
            ["P", "O", "O", "O"],
            ["O", "O", "O", "O"]
        ]));


//         Make a Circle with OOP

         // Your task is to create a Circle constructor that creates a circle with a radius provided by an argument.The circles constructed must have two getters getArea()(PIr ^ 2) and getPerimeter()(2PI * r) which give both respective areas and perimeter(circumference).

        //             For help with this class, I have provided you with a Rectangle constructor which you can use as a base example.
//                 Examples

//             let circy = new Circle(11);
//             circy.getArea();

//             // Should return 380.132711084365

//             let circy = new Circle(4.44);
//             circy.getPerimeter();

// Should return 27.897342763877365

        class Circle {
            constructor(radius) {
                this.radius = radius,
                this.getArea = () => {
                    return parseFloat((Math.PI * (this.radius ** 2)).toFixed(2));
                },
                this.getPerimeter = () => {
                    return parseFloat((2 * Math.PI * this.radius).toFixed(2))
                }
            }
        }

        let circy = new Circle(11);
        console.log(circy.getArea());

        let circy2 = new Circle(4.44);
        console.log(circy2.getPerimeter());


    // Write a Simple Console Object

    // The objective of this challenge is to create a console Object.You should write three working functions inside to complete this challenge:

    // Create a log function that takes user arguments and returns them as a string.
    // Create a history function that takes an optional range as an argument.
    // Create a clearHistory function to remove the history memory.

    //     Examples

    // myConsole.log([0, 1, 2, 3]) ➞ "[0,1,2,3]"

    // myConsole.log("ok : ", function () { return "hello world !" }) ➞ "ok : function(){ return \"hello world !\"}"

    // myConsole.history() ➞ "[0,1,2,3]\nok : function(){ return \"hello world !\"}''

    // myConsole.clearHistory() ➞ true

    // myConsole.history() ➞ ""
        class Console {
            constructor() {
                this.store = []
                this.log = (param) => {
                    const newEntry = param.toString();
                    this.store.push(newEntry);
                    return newEntry;
                }
                this.history = (lowEnd, highEnd) => {
                    // return this.store !== [] ? this.store.join('\n') : '';
                    if (typeof lowEnd == 'number' || typeof highEnd == 'number' ) {
                        return this.store.slice(lowEnd - 1, highEnd).join('\n');
                    } else {
                        return this.store.join('\n');
                    }
                }
                this.clearHistory = () => {
                    this.store = [];
                    return true
                }
            }
        }

        const myNewConsole = new Console();
        console.log(myNewConsole.log('ooooooh, ah'));
        console.log(myNewConsole.log('helllooo'));
        console.log(myNewConsole.log(() => true));
        console.log(myNewConsole.history());
        console.log(myNewConsole.log(456));
        console.log(myNewConsole.history(1,2));
        console.log(myNewConsole.clearHistory());
        console.log(myNewConsole.history());


        // Digitaldrome

        //     In this challenge, you have to establish if the digits of a given number form a sequence(ascending or descending).

        //     Given an integer n, implement a function that returns a string:

        //     "Metadrome" if the digits of n form an ascending sequence without repeating digits;
        //     "Plaindrome" if the digits of n form an ascending sequence with repeating digits;
        //     "Katadrome" if the digits of n form a descending sequence without repeating digits;
        //     "Nialpdrome" if the digits of n form a descending sequence with repeating digits;
        //     "Repdrome" if n contains a single repeating digit;
        //     "Nondrome" if none of the above conditions is true.

        //         Examples

        //     digitaldrome(1357) ➞ "Metadrome"
        //     // Ascending sequence without repeating digits

        //     digitaldrome(12344) ➞ "Plaindrome"
        //     // Ascending sequence with repeating digits

        //     digitaldrome(7531) ➞ "Katadrome"
        //     // Descending sequence without repeating digits

        //     digitaldrome(9874441) ➞ "Nialpdrome"
        //     // Descending sequence with  repeating digits

        //     digitaldrome(666) ➞ "Repdrome"
        //     // There's only a single repeating digit

        //     digitaldrome(1985) ➞ "Nondrome"
        //     // This is not a sequence

        //     Notes

        //     Any given n will be a positive integer.

        const digitalDrome = (num) => {
            // return num
            //     .toString()
            //     .split('')
            //     .filter((int, index) => {
            //         console.log(int, index);
            //     })
            const numArray = num.toString().split('');
            const diffArray = [];
            numArray.map((int, index) => {
                diffArray.push(numArray[index + 1] - int)
            }).map(int)
        }

        const digitaldrome = n => {
            n = String(n);
            console.log(n.length, 'n.length value');
            let set = new Set(n).size;
            console.log(set, 'set value');
            if (set === 1) return "Repdrome";
            let sor = [...n].sort(),
                a = [n === sor.join(""), n === sor.reverse().join("")],
                b = set === n.length,
                res = [a[0] && b, a[1] && b, a[0] && !b, a[1] && !b];
                console.log(a, 'a value');
                console.log(b, 'b value');
                console.log(res, 'res value');
            return ["Metadrome", "Katadrome", "Plaindrome", "Nialpdrome"]
            [res.indexOf(true)] || "Nondrome";
        }

        console.log(digitaldrome(1357));

        // IndexOf and LastIndexOf

        //     Your task is to recreate two functions from String.object(indexOf() and lastIndexOf()).
        //         str.indexOf(searchValue[, fromIndex])

        //     This function will accept a string and regex as searched value, take a look at target string and return the first index if there is a match.

        //     searchValue is a string or a regex object representing the value to be searched.
        //     fromIndex is an optional parameter indicating the starting point(beginning from left) of your search.

        //     If any value matches, return the first index found, else return -1.
        //     str.lastIndexOf(searchValue[, fromIndex])

        //     This function is the same as indexOf except it will return the last index if there is a match.

        //     searchValue is a string or a regex object representing the value to be searched.
        //     fromIndex is an optional parameter indicating the index of beginning of matched strings.

        //     For example, with regex you can try to find all matches in the string but the lastIndexOf function must return the index of the character at the fromIndex parameter or lower.

        //     If any value matches, return the last index found, else return -1.

        const indexOf = (str, searchValue, fromIndex = 0) => {
            if (fromIndex > str.length) {
                return -1;
            }
            return str
                .split('')
                .map((letter, index) => {
                    if (index >= fromIndex && (letter === searchValue || letter.match(searchValue))) {
                        return index
                    } else {
                        return -1;
                    }
                })
                .sort((a, b) => a - b)
                // .find(indexValue => indexValue != -1 ? indexValue : -1)
                .join(' ')
                // .search(/[-1]/g);
        }

        const lastIndexOf = (str, searchValue, fromIndex = 0) => {
            return str
                .split('')
                .slice(fromIndex)
                .map((letter, index) => {
                    if (index >= fromIndex && (letter === searchValue || letter.match(searchValue))) {
                        return index;
                    } else {
                        return -1;
                    }
                })
                .sort((a, b) => b - a)[0]
        }

        // console.log(indexOf('wood', 'o'));
        // console.log(lastIndexOf('wood', 'o'));
        console.log(indexOf('ohello', 'o', 4));
        console.log(lastIndexOf('ohello', 'o'));

        // Find the Missing Number

        //     Create a function that takes an array of numbers between 1 and 10(excluding one number) and returns the missing number.
        //         Examples

        //     missingNum([1, 2, 3, 4, 6, 7, 8, 9, 10]) ➞ 5

        //     missingNum([7, 2, 3, 6, 5, 9, 1, 4, 8]) ➞ 10

        //     missingNum([10, 5, 1, 2, 4, 6, 8, 3, 9]) ➞ 7

        //     Notes

        //     The array of numbers will be unsorted(not in order).
        //     Only one number will be missing.

        const missingNum = (arr) => {
            return arr
                .sort((a,b) => a - b)
                .filter((num, index, arr) => {
                    if (arr[index + 1] - num !== 1) {
                        return num;
                    } else if (index === 0 && num != 1) {
                        return 0;
                    }
                })[0] + 1
        }

        const testArr = [1, 2, 3, 5, 6, 7, 8, 9, 10];
        const testArr2 = [10, 5, 1, 2, 4, 6, 8, 3, 9];
        const testArr3 = [7, 2, 3, 6, 5, 9, 1, 4, 8];
        const testArr4 = [2, 3, 4, 5, 6, 7, 8, 9, 10]
        // console.log(missingNum(testArr));
        // console.log(missingNum(testArr2));
        // console.log(missingNum(testArr3));
        console.log(missingNum(testArr4));

//         Write a function that, given a date(in the format MM / DD / YYYY), returns the day of the week as a string.Each day name must be one of the following strings: "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", or "Saturday".

//             To illustrate, the day of the week for "12/07/2016" is "Wednesday".
//                 Examples

// getDay("12/07/2016") ➞ "Wednesday"

//             getDay("09/04/2016") ➞ "Sunday"

//             getDay("12/08/2011") ➞ "Thursday"

        // const getDay = (str) => {
        //     const [month, day, year] = str.split("/");
        //     const indexWeek = new Date(year, month - 1, day).getDay();
        //     const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

        //     return daysOfWeek.find((date, index) => {
        //         if (index === indexWeek) {
        //             return date;
        //         }
        //     });
        // }

        const getDay = day => new Date(day).toLocaleString('en-us', { weekday: 'long' });

        console.log(getDay("12/07/2016"));
        console.log(getDay("12/14/2019"));

        // Reverse Coding Challenge #6

        //     This is a reverse coding challenge.Normally you're given explicit directions with how to create a function. Here, you must generate your own function to satisfy the relationship between the inputs and outputs.

        //     Your task is to create a function that, when fed the inputs below, produces the sample outputs shown.
        //         Examples

        //     mysteryFunc(152) ➞ 10

        //     mysteryFunc(832) ➞ 48

        //     mysteryFunc(19) ➞ 9

        //     mysteryFunc(133) ➞ 9

        const mysteryFunc = (num) => {
            return num
                .toString()
                .split('')
                .reverse()
                .reduce((a, b, index, arr) => {
                    return a * b;
                });
        }

        console.log(mysteryFunc(152));
        console.log(mysteryFunc(832));

        // Lowercase and Uppercase Map

        //     Write a function that creates an object with each(key, value) pair being the(lower case, upper case) versions of a letter, respectively.
        //         Examples

        //     mapping(["p", "s"]) ➞ { "p": "P", "s": "S" }

        //     mapping(["a", "b", "c"]) ➞ { "a": "A", "b": "B", "c": "C" }

        //     mapping(["a", "v", "y", "z"]) ➞ { "a": "A", "v": "V", "y": "Y", "z": "Z" }

        const mapping = (arr) => {
            const obj = {}
            arr.map(letter => {
                if (!obj[letter]) {
                    obj[letter] = letter.toUpperCase();
                }
            });
            return obj;
        }

        console.log(mapping(["p", "s", "s"]));
        console.log(mapping(["a", "b", "c", "a"]));

        // One Button Messaging Device

        // Imagine a messaging device with only one button.For the letter A, you press the button one time, for E, you press it five times, for G, it's pressed seven times, etc, etc.

        // Write a function that takes a string(the message) and returns the total number of times the button is pressed.
        //     Examples

        // howManyTimes("abde") ➞ 12

        // howManyTimes("azy") ➞ 52

        // howManyTimes("qudusayo") ➞ 123

        // Notes

        // Ignore spaces.

        const howManyTimes = (str) => {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            return [...str]
                .map(letter => {
                    return (alphabet.indexOf(letter) + 1);
                })
                .reduce((a,b) => a + b)
        }

        console.log(howManyTimes("abde"));
        console.log(howManyTimes("azy"));
        console.log(howManyTimes("qudusayo"));

        // Online Shopping

        //     Create a function that determines whether a shopping order is eligible for free shipping.An order is eligible for free shipping if the total cost of items purchased exceeds $50.00.
        //         Examples

        //     freeShipping({ "Shampoo": 5.99, "Rubber Ducks": 15.99 }) ➞ false

        //     freeShipping({ "Flatscreen TV": 399.99 }) ➞ true

        //     freeShipping({ "Monopoly": 11.99, "Secret Hitler": 35.99, "Bananagrams": 13.99 }) ➞ true

        //     Notes

        //     Ignore tax or additional fees when calculating the total order cost.

        const freeShipping = (obj) => {
            const sum =  Object.values(obj).reduce((a,b) => a + b);
            return sum >= 50.00 ? true : false;
        }

        console.log(freeShipping({ "Shampoo": 5.99, "Rubber Ducks": 15.99 }));
        console.log(freeShipping({ "Flatscreen TV": 399.99 }));

        // Is Johnny Making Progress ?

        //         To train for an upcoming marathon, Johnny goes on one long - distance run each Saturday.He wants to track how often the number of miles he runs this Saturday exceeds the number of miles run the previous Saturday.This is called a progress day.

        //     Create a function that takes in an array of miles run every Saturday and returns Johnny's total number of progress days.
        //     Examples

        //     progressDays([3, 4, 1, 2]) ➞ 2
        //     // There are two progress days, (3->4) and (1->2)

        //     progressDays([10, 11, 12, 9, 10]) ➞ 3

        //     progressDays([6, 5, 4, 3, 2, 9]) ➞ 1

        //     progressDays([9, 9]) ➞ 0

        //     Notes

        //     Running the same number of miles as last week does not count as a progress day.

        const progressDays = (arr) => {
            return arr.filter((mile, index, arr) => {
                if (arr[index + 1] > mile) {
                    return 1;
                }
            }).length
        }
        
        console.log(progressDays([3, 4, 1, 2]));
        console.log(progressDays([10, 11, 12, 9, 10]));
        console.log(progressDays([6, 5, 4, 3, 2, 9]));
        console.log(progressDays([9, 9]));
</script>
</body>
</html>