<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Code-Wars Daily Challenges</title>
</head>
<body>
<script>
    // Your task is to convert strings to how they would be written by Jaden Smith.The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

    //         Example:

    //     Not Jaden - Cased: "How can mirrors be real if our eyes aren't real"
    //     Jaden - Cased: "How Can Mirrors Be Real If Our Eyes Aren't Real"

    const jadenCased = (str) => {
        const array = str.split(' ');
        let finalArray = [];
        for (word of array) {
            const uppercaseArray = [...word];
            let uppercaseLetter = uppercaseArray[0].toUpperCase();
            uppercaseArray.shift();
            uppercaseArray.unshift(uppercaseLetter);
            const jadenCasedWord = uppercaseArray.join('');  
            finalArray.push(jadenCasedWord);
        }
        const jadenCasedSentence = finalArray.join(' ');
        return console.log(jadenCasedSentence);
    }

    jadenCased("How can mirrors be real if our eyes aren't real");


    //Descending Order
    // Your task is to make a function that can take any non - negative integer as a argument and return it with its digits in descending order.Essentially, rearrange the digits to create the highest possible number.
    //         Examples:

    //     Input: 21445 Output: 54421

    //     Input: 145263 Output: 654321

    //     Input: 1254859723 Output: 9875543221

    const descendingOrder = number => {
        if (typeof number != 'number') {
            return console.log('put in a number ya fool!');
        }

        const numberStr = number.toString();
        const numberArray = [...numberStr];
        const sortedNumberArray = numberArray.sort();
        let reverseSortedArray = [];
        for (value of sortedNumberArray) {
            reverseSortedArray.unshift(value);
        }

        reverseNumberStr = reverseSortedArray.join('');
        const reverseNumber = Number(reverseNumberStr);
        return reverseNumber;
    }

    descendingOrder(21445);
    descendingOrder(123456789);
    descendingOrder(1021);


    //Isogram
    
    // An isogram is a word that has no repeating letters, consecutive or non - consecutive.Implement a function that determines whether a string that contains only letters is an isogram.Assume the empty string is an isogram.Ignore letter case.

    //     isIsogram("Dermatoglyphics") == true
    //     isIsogram("aba") == false
    //     isIsogram("moOse") == false // -- ignore letter case

    const isIsogram = str => {
        const lowerCaseStr = str.toLowerCase();
        const strArray = [...lowerCaseStr];
        let letterCount = {};

        for (letter of strArray) {
            if (letterCount[letter] === undefined) {
                letterCount[letter] = 1;
            }
            else {
                letterCount[letter]++
                return console.log(false);
            }
        }

        return console.log(true);
    }

    isIsogram('the');
    isIsogram('aba');
    isIsogram('moOse');

//   Funny string attachment  

// This time no story, no theory. The examples below show you how to write function accum:

// Examples:

// accum("abcd") -> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt") -> "C-Ww-Aaa-Tttt"

// The parameter of accum is a string which includes only letters from a..z and A..Z.

    const strAccum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        let newArray = [];

        for (let i = 0; i <= strArray.length - 1; i++) {
            if (i === 0) {
                const firstLetter = strArray[i];
                newArray.push(firstLetter + '-');
            }
            else if(i > 0 && i < strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i) + '-');
            }
            else if (i === strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i));
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(strAccum('abcd'));
    console.log(strAccum('cwAT'));

    const accum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        const newArray = strArray.map((letter, i) => {
            return letter + letter.toLowerCase().repeat(i);
        });
        const finalStr = newArray.join('-');
        return finalStr;
    }

    console.log(accum('abcd'));
    console.log(accum('cwAT'));

    // Given: an array containing hashes of names

    //     Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.

    //         Example:

    //     list([{ name: 'Bart' }, { name: 'Lisa' }, { name: 'Maggie' }])
    //     // returns 'Bart, Lisa & Maggie'

    //     list([{ name: 'Bart' }, { name: 'Lisa' }])
    //     // returns 'Bart & Lisa'

    //     list([{ name: 'Bart' }])
    //     // returns 'Bart'

    //     list([])
// returns ''

    const arrayList = [{name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'}];

    const list = array => {
            let newArray = [];
            for (obj of array) {
                newArray.push(obj.name);
            }
            const finalStr = newArray.map((name, i) => {
                if ((newArray.length - 1) === 0) {
                    return name;
                }
                else if (i === (newArray.length - 1)) {
                    return '& ' + name;
                }
                else if (i === (newArray.length - 2)) {
                    return name;
                }
                return name + ','
            }).join(' ');
            
            return finalStr;
    }

    console.log(list(arrayList)); 


    // Array Diff
    // Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

    //     It should remove all values from list a, which are present in list b.

    //         array_diff([1, 2], [1]) == [2]

    //     If a value is present in b, all of its occurrences must be removed from the other:

    //     array_diff([1, 2, 2, 2, 3], [2]) == [1, 3]

    const array_diff = (array1, array2) => {
        return array1.filter(item => {
            //very interesting quirk here with .filter() method, it doesn't return values of 0 in an array
            //this is because the value of 0 returns falsy, so filter doesn't recognize it and therefore doesn't return it in the new array
            return !array2.includes(item);
        })
    }

    console.log(array_diff([1, 2, 2, 2, 3, 0], [2]));



    // Write a function using recursion that takes a base and an exponent and outputs the power.

    //     e.g.

    //     power(2, 3) -> 8

    // power(4, 2) -> 16


    const power = (base, exponent) => {
        if (exponent <= 1) {
            return base
        }
        else {
            return base * power(base, exponent - 1);
        }
    }


    console.log(power(2, 3));
    console.log(power(4, 2));



    // Write a function that takes two arrays and returns their intersection as an array.

    //     intersection([1, 2, 3], [2, 3, 4]) -> [2, 3]

    // intersection([a, 1, 'foo'], ['foo', 17, a]) -> [a, 'foo']

    const intersection = (array1, array2) => {
        return array1.filter(item => {
            return array2.includes(item);
        })
    }

    console.log(intersection([1, 2, 3], [2, 3, 4]));
    console.log(intersection(['a', 1, 'foo'], ['foo', 17, 'a']));




    // Write a function that weaves 2 strings together.If one string is longer than the other, attach all letters left at the end.

    //     weave('abc', '123') -> 'a1b2c3'

    // weave('abcdefg', '123') -> 'a1b2c3defg'

    const weave = (str1, str2) => {
        const str1Array = [...str1];
        const str2Array = [...str2];
        let newArray = [];
        let length;

        if (str1Array.length - 1 > str2Array.length - 1) {
            length = str1Array.length - 1;
        }
        else {
            length = str2Array.length - 1;
        }

        for (let i = 0; i <= length; i++) {
            if (str1Array[i]){
                newArray.push(str1Array[i]);
            }
            if (str2Array[i]) {
                newArray.push(str2Array[i]);
            }
        }

        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(weave('abc', '123')); 
    console.log(weave('abcdefg', '123'));


    // Convert seconds to time format 
    
    // Write a function, which takes a non - negative integer(seconds) as input and returns the time in a human - readable format(HH: MM: SS)

    //     HH = hours, padded to 2 digits, range: 00 - 99
    //     MM = minutes, padded to 2 digits, range: 00 - 59
    //     SS = seconds, padded to 2 digits, range: 00 - 59

    //     The maximum time never exceeds 359999(99: 59: 59)

    //     You can find some examples in the test fixtures.

    const humanReadable = (secs) => {
        let seconds;

        let minutes = Math.floor(secs / 60).toString();
        let hours = Math.floor(secs / 3600).toString();
        seconds = (secs % 60).toString();
        
        if (hours >= 1) {
            minutes = (minutes % 60).toString();
        }
        if (hours >= 99) {
            hours = 99;
        }
        if (hours >= 0 && hours < 10) {
            hours = '0' + hours;
        }
        if (minutes >= 0 && minutes < 10) {
            minutes = '0' + minutes;
        }
        if (seconds >= 0 && seconds < 10) {
            seconds = '0' + seconds;
        }

        console.log(seconds);
        return `${hours}:${minutes}:${seconds}`;
    }

    console.log(humanReadable(1000));
    console.log(humanReadable(5));
    console.log(humanReadable(60));
    console.log(humanReadable(86399));
    console.log(humanReadable(359999));
    console.log(humanReadable(45296));

    const humanReadable2 = (time) => {
        //very interesting solution here
        //parseInt() will drop the decimal values on the number when converting to string
        const hours = parseInt(time / 3600);
        const minutes = parseInt(time / 60) % 60;
        const seconds = time % 60;
        //that gives us all of the values we needs

        const pad = (val) => {
            //this function creates the values we need for our final string
            //in a patterned fashion
            return val < 10 ? "0" + val : val;
        }

        return pad(hours) + ":" + pad(minutes) + ":" + pad(seconds);
    }

    //Write a function that counts the letters of multiple string values in an array
    //Then, return the letter count for each individual string as an object
    //Each object's letter count will be stored in an array to be returned by the function

    const countLetters = (array) => {
        let obj = {};
        let finalArray = [];

        for (word of array) {
            obj = {}
            let strArray = [...word];
            for (letter of strArray) {
                if (obj[letter] === undefined) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++
                }
            }
            finalArray.push(obj);
        }
        return finalArray;
    }

    console.log(countLetters(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    const countLetters2 = array => {
        return array.map(string => {
            const obj = {};
            [...string].map(letter => {
                if (!obj[letter]) {
                    obj[letter] = 1;
                }
                else {
                    obj[letter]++;
                }
            })
            return obj
        })
    }

    console.log(countLetters2(['mmgdsdwqulhrinkatfjoyzxcbvq', 'megsdwpulhrinkasfjdyzxcbvk']));

    //Find Int
    
    // Given an array, find the int that appears an odd number of times.

    //     There will always be only one integer that appears an odd number of times.

    const findOdd = (array) => {
        const obj = {}
        array.map(number => {
            if (!obj[number]) {
                obj[number] = 1;
            }
            else {
                obj[number]++;
            }
        })
        for (key in obj) {
            if (obj[key] % 2 !== 0) {
                return Number(key);
            }
        }
    }
    

    console.log(findOdd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    const findOdd2 = (xs) => xs.reduce((a, b) => a ^ b);

    console.log(findOdd2([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]));

    console.log([ 1, 1, 2, 7, 2, 3, 3].reduce((a,b) => a ^ b));


    // A Narcissistic Number is a number which is the sum of its own digits, each raised to the power of the number of digits in a given base.In this Kata, we will restrict ourselves to decimal(base 10).

//     For example, take 153(3 digits):

//     1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 1 + 125 + 27 = 153

//     and 1634(4 digits):

//     1 ^ 4 + 6 ^ 4 + 3 ^ 4 + 4 ^ 4 = 1 + 1296 + 81 + 256 = 1634

//     The Challenge:

//     Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

//     Error checking for text strings or other invalid inputs is not required, only valid integers will be passed into the function.

    const narcissistic = num => {
        const numStr = `${num}`
        const numArray = [...numStr];
        const length = numArray.length;

        const finalSum = numArray
        .map(number =>  number ** length)
        .reduce((a,b) => a + b);

        if (finalSum === num) return true;
        else return false;
    }

    console.log(narcissistic(7));
    console.log(narcissistic(371));

    // Three conditions must be met for a valid experiment:

    //         Float parameter "h" in meters must be greater than 0
    //     Float parameter "bounce" must be greater than 0 and less than 1
    //     Float parameter "window" must be less than h.

    //     If all three conditions above are fulfilled, return a positive integer, otherwise return -1.
    //     Note:

    //     The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.

    const bouncingBalls = (h, b, w) => {
        const height = h > 0;
        const bounce = b < 1 && b > 0;
        const windowHeight = w < h;

        if (height && bounce && windowHeight) {
            let count = 1;
            let bounceHeight = b * h;

            for (i = bounceHeight; i > w; i *= b) {
                count = count + 2;
            }
            return count;
        }
        else return -1;
    }

    console.log(bouncingBalls(3, .66, 1.5));
    console.log(bouncingBalls(30, .66, 1.5));

    // Complete the method / function so that it converts dash / underscore delimited words into camel casing.The first word within the output should be capitalized only if the original word was capitalized(known as Upper Camel Case, also often referred to as Pascal case).
    //         Examples

    //     toCamelCase("the-stealth-warrior") // returns "theStealthWarrior"

    //     toCamelCase("The_Stealth_Warrior") // returns "TheStealthWarrior"

    // const toCamelCase = (str) => {
    //     if (str === '') return 
        
    //     const strArray = str.split(/[-_]+/g);
        
    //     const newArray = strArray.map(word => {
    //         if (word === strArray[0] && strArray[0] === strArray[0].toLowerCase()) {
    //             return word.replace(word[0], word[0].toLowerCase())
    //         }
    //         else {
    //             return word.replace(word[0], word[0].toUpperCase());
    //         }
    //     })  
    //     return newArray.join('');
    // }


    const toCamelCase = (str) => {
        const regExp = /[-_]\w/ig;
        return str.replace(regExp, (match) => {
            return match.charAt(1).toUpperCase();
        });
    }

    console.log(toCamelCase('the-stealth-warrior'));
    console.log(toCamelCase("The_Stealth_Warrior"));

    // Write a function that accepts an array of 10 integers(between 0 and 9), that returns a string of those numbers in the form of a phone number.
    //         Example:

    //     createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"

    //     The returned format must be correct in order to complete this challenge.
    //         Don't forget the space after the closing parenthesis!

    const createPhoneNumber = (array) => {
        return array.map((number, index) => {
            if (index === 0){
                return `(${number}`;
            }
            if (index === 2) {
                return `${number})`;
            }
            if (index === 3) {
                return ` ${number}`
            }
            if (index === 5) {
                return `${number}-`
            }
            return number;
        }).join('');
    }

    console.log(createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]));


</script>
</body>
</html>