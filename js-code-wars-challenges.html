<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Code-Wars Daily Challenges</title>
</head>
<body>
<script>
    // Your task is to convert strings to how they would be written by Jaden Smith.The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

    //         Example:

    //     Not Jaden - Cased: "How can mirrors be real if our eyes aren't real"
    //     Jaden - Cased: "How Can Mirrors Be Real If Our Eyes Aren't Real"

    const jadenCased = (str) => {
        const array = str.split(' ');
        let finalArray = [];
        for (word of array) {
            const uppercaseArray = [...word];
            let uppercaseLetter = uppercaseArray[0].toUpperCase();
            uppercaseArray.shift();
            uppercaseArray.unshift(uppercaseLetter);
            const jadenCasedWord = uppercaseArray.join('');  
            finalArray.push(jadenCasedWord);
        }
        const jadenCasedSentence = finalArray.join(' ');
        return console.log(jadenCasedSentence);
    }

    jadenCased("How can mirrors be real if our eyes aren't real");


    //Descending Order
    // Your task is to make a function that can take any non - negative integer as a argument and return it with its digits in descending order.Essentially, rearrange the digits to create the highest possible number.
    //         Examples:

    //     Input: 21445 Output: 54421

    //     Input: 145263 Output: 654321

    //     Input: 1254859723 Output: 9875543221

    const descendingOrder = number => {
        if (typeof number != 'number') {
            return console.log('put in a number ya fool!');
        }

        const numberStr = number.toString();
        const numberArray = [...numberStr];
        const sortedNumberArray = numberArray.sort();
        let reverseSortedArray = [];
        for (value of sortedNumberArray) {
            reverseSortedArray.unshift(value);
        }

        reverseNumberStr = reverseSortedArray.join('');
        const reverseNumber = Number(reverseNumberStr);
        return reverseNumber;
    }

    descendingOrder(21445);
    descendingOrder(123456789);
    descendingOrder(1021);


    //Isogram
    
    // An isogram is a word that has no repeating letters, consecutive or non - consecutive.Implement a function that determines whether a string that contains only letters is an isogram.Assume the empty string is an isogram.Ignore letter case.

    //     isIsogram("Dermatoglyphics") == true
    //     isIsogram("aba") == false
    //     isIsogram("moOse") == false // -- ignore letter case

    const isIsogram = str => {
        const lowerCaseStr = str.toLowerCase();
        const strArray = [...lowerCaseStr];
        let letterCount = {};

        for (letter of strArray) {
            if (letterCount[letter] === undefined) {
                letterCount[letter] = 1;
            }
            else {
                letterCount[letter]++
                return console.log(false);
            }
        }

        return console.log(true);
    }

    isIsogram('the');
    isIsogram('aba');
    isIsogram('moOse');

//   Funny string attachment  

// This time no story, no theory. The examples below show you how to write function accum:

// Examples:

// accum("abcd") -> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt") -> "C-Ww-Aaa-Tttt"

// The parameter of accum is a string which includes only letters from a..z and A..Z.

    const strAccum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        let newArray = [];

        for (let i = 0; i <= strArray.length - 1; i++) {
            if (i === 0) {
                const firstLetter = strArray[i];
                newArray.push(firstLetter + '-');
            }
            else if(i > 0 && i < strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i) + '-');
            }
            else if (i === strArray.length - 1) {
                newArray.push(strArray[i]);
                let letter = strArray[i].toLowerCase() + '';
                newArray.push(letter.repeat(i));
            }
        }
        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(strAccum('abcd'));
    console.log(strAccum('cwAT'));

    const accum = (str) => {
        const upperStr = str.toUpperCase();
        const strArray = [...upperStr];
        const newArray = strArray.map((letter, i) => {
            return letter + letter.toLowerCase().repeat(i);
        });
        const finalStr = newArray.join('-');
        return finalStr;
    }

    console.log(accum('abcd'));
    console.log(accum('cwAT'));

    // Given: an array containing hashes of names

    //     Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.

    //         Example:

    //     list([{ name: 'Bart' }, { name: 'Lisa' }, { name: 'Maggie' }])
    //     // returns 'Bart, Lisa & Maggie'

    //     list([{ name: 'Bart' }, { name: 'Lisa' }])
    //     // returns 'Bart & Lisa'

    //     list([{ name: 'Bart' }])
    //     // returns 'Bart'

    //     list([])
// returns ''

    const arrayList = [{name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'}];

    const list = array => {
            let newArray = [];
            for (obj of array) {
                newArray.push(obj.name);
            }
            const finalStr = newArray.map((name, i) => {
                if ((newArray.length - 1) === 0) {
                    return name;
                }
                else if (i === (newArray.length - 1)) {
                    return '& ' + name;
                }
                else if (i === (newArray.length - 2)) {
                    return name;
                }
                return name + ','
            }).join(' ');
            
            return finalStr;
    }

    console.log(list(arrayList)); 


    // Array Diff
    // Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

    //     It should remove all values from list a, which are present in list b.

    //         array_diff([1, 2], [1]) == [2]

    //     If a value is present in b, all of its occurrences must be removed from the other:

    //     array_diff([1, 2, 2, 2, 3], [2]) == [1, 3]

    const array_diff = (array1, array2) => {
        return array1.filter(item => {
            //very interesting quirk here with .filter() method, it doesn't return values of 0 in an array
            //this is because the value of 0 returns falsy, so filter doesn't recognize it and therefore doesn't return it in the new array
            return !array2.includes(item);
        })
    }

    console.log(array_diff([1, 2, 2, 2, 3, 0], [2]));



    // Write a function using recursion that takes a base and an exponent and outputs the power.

    //     e.g.

    //     power(2, 3) -> 8

    // power(4, 2) -> 16


    const power = (base, exponent) => {
        if (exponent <= 1) {
            return base
        }
        else {
            return base * power(base, exponent - 1);
        }
    }


    console.log(power(2, 3));
    console.log(power(4, 2));



    // Write a function that takes two arrays and returns their intersection as an array.

    //     intersection([1, 2, 3], [2, 3, 4]) -> [2, 3]

    // intersection([a, 1, 'foo'], ['foo', 17, a]) -> [a, 'foo']

    const intersection = (array1, array2) => {
        return array1.filter(item => {
            return array2.includes(item);
        })
    }

    console.log(intersection([1, 2, 3], [2, 3, 4]));
    console.log(intersection(['a', 1, 'foo'], ['foo', 17, 'a']));




    // Write a function that weaves 2 strings together.If one string is longer than the other, attach all letters left at the end.

    //     weave('abc', '123') -> 'a1b2c3'

    // weave('abcdefg', '123') -> 'a1b2c3defg'

    const weave = (str1, str2) => {
        const str1Array = [...str1];
        const str2Array = [...str2];
        let newArray = [];
        let length;

        if (str1Array.length - 1 > str2Array.length - 1) {
            length = str1Array.length - 1;
        }
        else {
            length = str2Array.length - 1;
        }

        for (let i = 0; i <= length; i++) {
            if (str1Array[i]){
                newArray.push(str1Array[i]);
            }
            if (str2Array[i]) {
                newArray.push(str2Array[i]);
            }
        }

        const finalStr = newArray.join('');
        return finalStr;
    }

    console.log(weave('abc', '123')); 
    console.log(weave('abcdefg', '123'));


    // Convert seconds to time format 
    
    // Write a function, which takes a non - negative integer(seconds) as input and returns the time in a human - readable format(HH: MM: SS)

    //     HH = hours, padded to 2 digits, range: 00 - 99
    //     MM = minutes, padded to 2 digits, range: 00 - 59
    //     SS = seconds, padded to 2 digits, range: 00 - 59

    //     The maximum time never exceeds 359999(99: 59: 59)

    //     You can find some examples in the test fixtures.

    const humanReadable = (secs) => {
        let seconds;

        let minutes = Math.floor(secs / 60).toString();
        let hours = Math.floor(secs / 3600).toString();
        seconds = (secs % 60).toString();
        
        if (hours >= 1) {
            minutes = (minutes % 60).toString();
        }
        if (hours >= 99) {
            hours = 99;
        }
        if (hours >= 0 && hours < 10) {
            hours = '0' + hours;
        }
        if (minutes >= 0 && minutes < 10) {
            minutes = '0' + minutes;
        }
        if (seconds >= 0 && seconds < 10) {
            seconds = '0' + seconds;
        }

        console.log(seconds);
        return `${hours}:${minutes}:${seconds}`;
    }

    console.log(humanReadable(1000));
    console.log(humanReadable(5));
    console.log(humanReadable(60));
    console.log(humanReadable(86399));
    console.log(humanReadable(359999));
    console.log(humanReadable(45296));

    humanReadable = (seconds) => {
        //very interesting solution here
        //parseInt() will drop the decimal values on the number when converting to string
        const hours = parseInt(seconds / 3600);
        const minutes = parseInt(seconds / 60) % 60;
        const seconds = seconds % 60;
        //that gives us all of the values we needs

        const pad = (val) => {
            //this function creates the values we need for our final string
            //in a patterned fashion
            return val < 10 ? "0" + val : val;
        }

        return pad(hours) + ":" + pad(minutes) + ":" + pad(seconds);
    }
</script>
</body>
</html>